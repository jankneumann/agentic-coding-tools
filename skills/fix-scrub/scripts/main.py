#!/usr/bin/env python3
"""Fix-scrub orchestrator: classify, plan, execute auto-fixes, verify, and report.

Agent-fix dispatch happens in the SKILL.md layer using Task() â€” this orchestrator
generates prompts but does not execute agent fixes.
"""

from __future__ import annotations

import argparse
import json
import sys
from pathlib import Path

sys.path.insert(0, str(Path(__file__).resolve().parent))

from classify import classify  # noqa: E402
from execute_auto import execute_auto_fixes  # noqa: E402
from generate_prompts import generate_prompts  # noqa: E402
from fix_models import ClassifiedFinding, Finding, FindingOrigin  # noqa: E402
from plan_fixes import plan  # noqa: E402
from render_fix_report import render_fix_report, write_fix_report  # noqa: E402
from track_completions import track_completions  # noqa: E402
from verify import verify  # noqa: E402


def _load_findings(report_path: str) -> list[Finding]:
    """Load findings from a bug-scrub JSON report."""
    try:
        with open(report_path) as f:
            data = json.load(f)
    except json.JSONDecodeError as exc:
        print(f"Warning: Bug-scrub report has invalid JSON: {exc}")
        print("The report may have been generated by a different version.")
        return []
    except OSError as exc:
        print(f"Warning: Cannot read bug-scrub report: {exc}")
        return []

    findings: list[Finding] = []
    for fd in data.get("findings", []):
        origin = None
        if fd.get("origin"):
            origin = FindingOrigin(
                change_id=fd["origin"].get("change_id", ""),
                artifact_path=fd["origin"].get("artifact_path", ""),
                task_number=fd["origin"].get("task_number"),
                line_in_artifact=fd["origin"].get("line_in_artifact"),
            )
        findings.append(
            Finding(
                id=fd.get("id", ""),
                source=fd.get("source", ""),
                severity=fd.get("severity", "info"),
                category=fd.get("category", "lint"),
                title=fd.get("title", ""),
                detail=fd.get("detail", ""),
                file_path=fd.get("file_path", ""),
                line=fd.get("line"),
                age_days=fd.get("age_days"),
                origin=origin,
            )
        )
    return findings


def run(
    report_path: str,
    tier_filter: list[str] | None = None,
    severity: str = "medium",
    dry_run: bool = False,
    max_agent_fixes: int = 10,
    project_dir: str | None = None,
    out_dir: str | None = None,
) -> int:
    """Run fix-scrub: classify, plan, execute, verify, report.

    Returns:
        0 for clean, 1 for regressions or manual items.
    """
    if project_dir is None:
        project_dir = str(Path.cwd())
    if out_dir is None:
        out_dir = str(Path(project_dir) / "docs" / "bug-scrub")
    if tier_filter is None:
        tier_filter = ["auto", "agent"]

    # Load findings
    if not Path(report_path).exists():
        print(f"Error: Bug-scrub report not found at {report_path}")
        print("Run /bug-scrub first to generate a report.")
        return 1

    print(f"Loading findings from {report_path}...")
    findings = _load_findings(report_path)
    print(f"  Loaded {len(findings)} findings")

    # Classify
    print("Classifying findings...")
    classified = classify(findings, severity_filter=severity)
    print(f"  Classified {len(classified)} findings at/above severity '{severity}'")

    # Plan
    fix_plan = plan(classified, max_agent_fixes=max_agent_fixes, dry_run=dry_run)
    print(f"\nFix Plan:")
    print(f"  Auto: {fix_plan.summary.get('auto', 0)}")
    print(f"  Agent: {fix_plan.summary.get('agent', 0)}")
    print(f"  Manual: {fix_plan.summary.get('manual', 0)}")

    if dry_run:
        print("\n--- DRY RUN: No changes applied ---")
        print(json.dumps(fix_plan.to_dict(), indent=2))
        return 0

    auto_resolved: list[ClassifiedFinding] = []
    agent_resolved: list[ClassifiedFinding] = []

    # Execute auto-fixes
    if "auto" in tier_filter and fix_plan.auto_groups:
        print("\nApplying auto-fixes...")
        resolved, persisting = execute_auto_fixes(fix_plan.auto_groups, project_dir)
        auto_resolved = resolved
        print(f"  Resolved: {len(resolved)}, Persisting: {len(persisting)}")

    # Generate agent prompts (execution happens in SKILL.md layer)
    agent_prompts: list[tuple[str, str]] = []
    if "agent" in tier_filter and fix_plan.agent_groups:
        print("\nGenerating agent-fix prompts...")
        agent_prompts = generate_prompts(fix_plan.agent_groups)
        print(f"  Generated {len(agent_prompts)} prompts")
        # Write prompts to JSON for SKILL.md consumption
        prompts_path = str(Path(out_dir) / "agent-fix-prompts.json")
        with open(prompts_path, "w") as f:
            json.dump(
                [{"file": fp, "prompt": p} for fp, p in agent_prompts],
                f,
                indent=2,
            )
        print(f"  Prompts written to {prompts_path}")

    # Track OpenSpec task completions
    all_resolved = auto_resolved + agent_resolved
    tasks_updated = track_completions(all_resolved, project_dir)
    if tasks_updated:
        print(f"\nOpenSpec tasks updated: {len(tasks_updated)}")
        for tp in tasks_updated:
            print(f"  - {tp}")

    # Verify
    print("\nRunning quality checks...")
    verification = verify(project_dir)
    print(f"  Passed: {verification.passed}")
    for tool, result in verification.checks.items():
        icon = "pass" if result == "pass" else "FAIL"
        print(f"  {tool}: {icon}")
    if verification.regressions:
        print(f"  Regressions: {len(verification.regressions)}")

    # Report
    report_content = render_fix_report(
        auto_resolved=auto_resolved,
        agent_resolved=agent_resolved,
        manual_remaining=fix_plan.manual_findings,
        tasks_completed=tasks_updated,
        verification=verification,
    )
    report_path_out = write_fix_report(report_content, out_dir)
    print(f"\nReport written: {report_path_out}")

    return 1 if (verification.regressions or fix_plan.manual_findings) else 0


def main() -> None:
    parser = argparse.ArgumentParser(description="Fix-scrub: remediation from bug-scrub report")
    parser.add_argument(
        "--report",
        type=str,
        default="docs/bug-scrub/bug-scrub-report.json",
        help="Path to bug-scrub JSON report",
    )
    parser.add_argument(
        "--tier",
        type=str,
        default="auto,agent",
        help="Comma-separated tiers to apply (auto, agent, manual)",
    )
    parser.add_argument(
        "--severity",
        type=str,
        default="medium",
        choices=["critical", "high", "medium", "low", "info"],
        help="Minimum severity to fix (default: medium)",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Plan fixes without applying them",
    )
    parser.add_argument(
        "--max-agent-fixes",
        type=int,
        default=10,
        help="Maximum agent-fix batch size (default: 10)",
    )
    parser.add_argument(
        "--project-dir",
        type=str,
        default=None,
        help="Project root directory",
    )
    parser.add_argument(
        "--out-dir",
        type=str,
        default=None,
        help="Output directory (default: docs/bug-scrub)",
    )
    args = parser.parse_args()

    tiers = args.tier.split(",")
    exit_code = run(
        report_path=args.report,
        tier_filter=tiers,
        severity=args.severity,
        dry_run=args.dry_run,
        max_agent_fixes=args.max_agent_fixes,
        project_dir=args.project_dir,
        out_dir=args.out_dir,
    )
    sys.exit(exit_code)


if __name__ == "__main__":
    main()
