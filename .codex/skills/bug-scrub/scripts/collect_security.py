#!/usr/bin/env python3
"""Signal collector for security review findings.

Parses the security-review-report.json generated by /security-review
and converts each finding into the canonical Finding model used by
bug-scrub and fix-scrub skills.
"""

from __future__ import annotations

import json
import os
import time
from typing import Any

from models import Finding, Severity, SourceResult

_REPORT_REL = os.path.join("docs", "security-review", "security-review-report.json")

_STALENESS_DAYS = 7

_VALID_SEVERITIES: set[str] = {"critical", "high", "medium", "low", "info"}


def _normalise_severity(raw: str) -> Severity:
    """Map the report severity string to a valid Severity literal.

    Unknown values fall back to ``"info"`` so we never reject a finding.
    """
    lower = raw.lower().strip()
    if lower in _VALID_SEVERITIES:
        return lower  # type: ignore[return-value]
    return "info"


def collect(project_dir: str) -> SourceResult:
    """Collect security findings from the security-review report.

    Parameters
    ----------
    project_dir:
        Absolute path to the project root.  The report is expected at
        ``docs/security-review/security-review-report.json`` relative to
        this directory.

    Returns
    -------
    SourceResult
        Normalised result with ``source="security"`` and
        ``category="security"`` for every finding.
    """
    start_ns = time.monotonic_ns()
    report_path = os.path.join(project_dir, _REPORT_REL)

    # ------------------------------------------------------------------
    # Missing file -> skipped (not an error)
    # ------------------------------------------------------------------
    if not os.path.isfile(report_path):
        duration_ms = (time.monotonic_ns() - start_ns) // 1_000_000
        return SourceResult(
            source="security",
            status="skipped",
            messages=[f"Security report not found: {report_path}"],
            duration_ms=duration_ms,
        )

    # ------------------------------------------------------------------
    # Parse report JSON
    # ------------------------------------------------------------------
    messages: list[str] = []
    try:
        with open(report_path, encoding="utf-8") as fh:
            data: dict[str, Any] = json.load(fh)
    except (json.JSONDecodeError, OSError) as exc:
        duration_ms = (time.monotonic_ns() - start_ns) // 1_000_000
        return SourceResult(
            source="security",
            status="error",
            messages=[f"Failed to parse security report: {exc}"],
            duration_ms=duration_ms,
        )

    # ------------------------------------------------------------------
    # Staleness check (file mtime)
    # ------------------------------------------------------------------
    try:
        mtime = os.path.getmtime(report_path)
        age_days = (time.time() - mtime) / 86_400
        if age_days > _STALENESS_DAYS:
            messages.append(
                f"Security report is {age_days:.0f} days old (>{_STALENESS_DAYS}d). "
                "Consider re-running /security-review."
            )
    except OSError:
        # Non-fatal: we already opened the file successfully.
        pass

    # ------------------------------------------------------------------
    # Convert findings
    # ------------------------------------------------------------------
    findings: list[Finding] = []
    raw_findings: list[dict[str, Any]] = data.get("findings", [])

    for entry in raw_findings:
        finding_id: str = str(entry.get("finding_id", ""))
        if not finding_id:
            continue

        severity = _normalise_severity(str(entry.get("severity", "info")))

        location: str = str(entry.get("location", ""))
        file_path = ""
        line: int | None = None
        if location:
            # Locations may be "path/to/file.py:42" or just "path/to/file.py"
            if ":" in location:
                parts = location.rsplit(":", 1)
                file_path = parts[0]
                try:
                    line = int(parts[1])
                except (ValueError, IndexError):
                    file_path = location
            else:
                file_path = location

        scanner: str = str(entry.get("scanner", ""))
        detail_parts: list[str] = []
        if entry.get("description"):
            detail_parts.append(str(entry["description"]))
        if scanner:
            detail_parts.append(f"Scanner: {scanner}")

        findings.append(
            Finding(
                id=f"sec-{finding_id}",
                source="security",
                severity=severity,
                category="security",
                title=str(entry.get("title", f"Security finding {finding_id}")),
                detail="\n".join(detail_parts),
                file_path=file_path,
                line=line,
            )
        )

    duration_ms = (time.monotonic_ns() - start_ns) // 1_000_000
    return SourceResult(
        source="security",
        status="ok",
        findings=findings,
        duration_ms=duration_ms,
        messages=messages,
    )
