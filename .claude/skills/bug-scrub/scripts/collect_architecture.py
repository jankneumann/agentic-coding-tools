#!/usr/bin/env python3
"""Signal collector: architecture diagnostics.

Parses ``docs/architecture-analysis/architecture.diagnostics.json`` and
converts each diagnostic finding into a :class:`Finding` for the bug-scrub
report.  The file is a static artifact (generated by ``make architecture``),
so this collector reads it from disk rather than invoking an external tool.

Staleness detection: if the diagnostics file was last modified more than
7 days ago a warning message is appended to the result so that the
aggregator can surface it in the final report.
"""

from __future__ import annotations

import json
import os
import time
from pathlib import Path

from models import Finding, SourceResult

SOURCE = "architecture"
CATEGORY = "architecture"

_DIAGNOSTICS_REL = os.path.join(
    "docs", "architecture-analysis", "architecture.diagnostics.json",
)

_STALENESS_THRESHOLD_DAYS = 7

_LEVEL_MAP: dict[str, str] = {
    "error": "high",
    "warning": "medium",
    "info": "low",
}


def _map_severity(level: str) -> str:
    """Map a diagnostic severity level to a finding severity.

    ``error`` -> ``"high"``, ``warning`` -> ``"medium"``,
    ``info`` -> ``"low"``.  Unknown levels default to ``"low"``.
    """
    return _LEVEL_MAP.get(level.lower(), "low")


def collect(project_dir: str) -> SourceResult:
    """Parse architecture diagnostics and return a :class:`SourceResult`.

    Parameters
    ----------
    project_dir:
        Absolute or relative path to the project root.  The diagnostics
        file is resolved as ``<project_dir>/docs/architecture-analysis/
        architecture.diagnostics.json``.

    Returns
    -------
    SourceResult
        ``status`` is ``"ok"`` on success (even if findings exist),
        ``"skipped"`` when the diagnostics file does not exist, or
        ``"error"`` on unexpected failures.
    """
    start = time.monotonic()

    diag_path = Path(project_dir) / _DIAGNOSTICS_REL

    # ------------------------------------------------------------------
    # Guard: does the diagnostics file exist?
    # ------------------------------------------------------------------
    if not diag_path.is_file():
        elapsed = int((time.monotonic() - start) * 1000)
        return SourceResult(
            source=SOURCE,
            status="skipped",
            duration_ms=elapsed,
            messages=[
                f"Architecture diagnostics file not found: {diag_path}",
            ],
        )

    # ------------------------------------------------------------------
    # Check staleness
    # ------------------------------------------------------------------
    messages: list[str] = []
    try:
        mtime = diag_path.stat().st_mtime
        age_days = (time.time() - mtime) / 86400
        if age_days > _STALENESS_THRESHOLD_DAYS:
            messages.append(
                f"Architecture diagnostics are {age_days:.0f} days old "
                f"(>{_STALENESS_THRESHOLD_DAYS}d). "
                "Run 'make architecture' to refresh."
            )
    except OSError:
        # Non-fatal â€” proceed even if stat fails.
        pass

    # ------------------------------------------------------------------
    # Parse JSON
    # ------------------------------------------------------------------
    try:
        raw = diag_path.read_text(encoding="utf-8")
        data = json.loads(raw)
    except (OSError, json.JSONDecodeError) as exc:
        elapsed = int((time.monotonic() - start) * 1000)
        return SourceResult(
            source=SOURCE,
            status="error",
            duration_ms=elapsed,
            messages=[f"Failed to read/parse diagnostics: {exc}"],
        )

    # ------------------------------------------------------------------
    # Convert diagnostics to findings
    # ------------------------------------------------------------------
    findings: list[Finding] = []
    raw_findings: list[dict] = data.get("findings", [])  # type: ignore[assignment]

    for idx, entry in enumerate(raw_findings):
        severity_raw: str = entry.get("severity", "info")
        category_raw: str = entry.get("category", "unknown")
        message: str = entry.get("message", "")
        file_path: str = entry.get("file", "")
        line: int | None = entry.get("line")
        suggestion: str = entry.get("suggestion", "")

        finding_id = f"arch-{category_raw}-{idx}"

        detail_parts: list[str] = []
        if message:
            detail_parts.append(message)
        if suggestion:
            detail_parts.append(f"Suggestion: {suggestion}")

        findings.append(
            Finding(
                id=finding_id,
                source=SOURCE,
                severity=_map_severity(severity_raw),  # type: ignore[arg-type]
                category=CATEGORY,  # type: ignore[arg-type]
                title=f"[{category_raw}] {message}",
                detail="\n".join(detail_parts),
                file_path=file_path,
                line=line,
            )
        )

    elapsed = int((time.monotonic() - start) * 1000)

    return SourceResult(
        source=SOURCE,
        status="ok",
        findings=findings,
        duration_ms=elapsed,
        messages=messages,
    )
