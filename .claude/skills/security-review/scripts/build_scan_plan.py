#!/usr/bin/env python3
"""Build scanner execution plan from detected project profiles."""

from __future__ import annotations

import argparse
import json
from pathlib import Path

from detect_profile import detect_profiles
from models import normalize_severity

ECOSYSTEM_PROFILES = {"python", "node", "java", "mixed", "generic"}


def build_plan(
    profile: dict[str, object],
    fail_on: str,
    zap_target: str | None,
    zap_mode: str,
) -> dict[str, object]:
    """Build scanner matrix for dependency and DAST scanners."""
    profiles = set(profile.get("profiles", []))
    scanners: list[dict[str, object]] = []

    dep_enabled = bool(profiles & ECOSYSTEM_PROFILES)
    scanners.append(
        {
            "scanner": "dependency-check",
            "enabled": dep_enabled,
            "reason": (
                "Ecosystem profile detected"
                if dep_enabled
                else "No dependency-bearing profile detected"
            ),
            "required_tools": ["java", "dependency-check or podman/docker-compatible runtime"],
            "runner": "skills/security-review/scripts/run_dependency_check.sh",
        }
    )

    zap_profile_match = "docker-api" in profiles or "mixed" in profiles
    zap_enabled = zap_profile_match
    if not zap_profile_match:
        zap_reason = "No DAST-capable profile detected"
    elif zap_target:
        zap_reason = "DAST target configured"
    else:
        zap_reason = "DAST-capable profile detected but no --zap-target provided"

    scanners.append(
        {
            "scanner": "zap",
            "enabled": zap_enabled,
            "reason": zap_reason,
            "mode": zap_mode,
            "target": zap_target,
            "target_required": zap_profile_match,
            "required_tools": ["podman or docker-compatible runtime"],
            "runner": "skills/security-review/scripts/run_zap_scan.sh",
        }
    )

    return {
        "profile": profile,
        "fail_on": normalize_severity(fail_on),
        "scanners": scanners,
    }


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("--repo", default=".", help="Repository root")
    parser.add_argument(
        "--profile-json",
        help="Optional profile JSON file generated by detect_profile.py",
    )
    parser.add_argument(
        "--profile-override",
        help="Comma-separated profile override (e.g., python,node)",
    )
    parser.add_argument(
        "--zap-target",
        default="",
        help="Target URL for ZAP scans (required for DAST execution)",
    )
    parser.add_argument(
        "--zap-mode",
        choices=["baseline", "api", "full"],
        default="baseline",
        help="ZAP scan mode",
    )
    parser.add_argument(
        "--fail-on",
        choices=["info", "low", "medium", "high", "critical"],
        default="high",
        help="Severity threshold for gate failure",
    )
    parser.add_argument("--pretty", action="store_true", help="Pretty-print JSON")
    return parser.parse_args()


def load_profile(args: argparse.Namespace) -> dict[str, object]:
    if args.profile_json:
        return json.loads(Path(args.profile_json).read_text(encoding="utf-8"))

    profile = detect_profiles(Path(args.repo).resolve())
    if not args.profile_override:
        return profile

    overridden = [p.strip() for p in args.profile_override.split(",") if p.strip()]
    if not overridden:
        return profile

    return {
        **profile,
        "primary_profile": "mixed" if len(overridden) > 1 else overridden[0],
        "profiles": sorted(set(overridden + (["mixed"] if len(overridden) > 1 else []))),
        "confidence": "high",
        "signals": sorted(set(profile.get("signals", []))),
        "override": True,
    }


def main() -> int:
    args = parse_args()
    profile = load_profile(args)
    plan = build_plan(
        profile=profile,
        fail_on=args.fail_on,
        zap_target=args.zap_target or None,
        zap_mode=args.zap_mode,
    )
    print(json.dumps(plan, indent=2 if args.pretty else None))
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
